#include <iostream>
#include <FL/Fl.H>
#include <FL/Fl_Window.H>
#include <FL/Fl_Box.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Input.H>
#include <FL/Fl_Image.H>
#include <FL/Fl_Menu_Item.H>
#include <FL/Fl_Menu_Bar.H>
#include <FL/Fl_Slider.H>
#include <FL/Fl_Value_Slider.H>
#include <FL/Fl_Value_Input.H>
#include <FL/Fl_Multiline_Output.H>
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_Group.H>
#include <FL/Fl_Scroll.H>
#include <algorithm>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <map>

void make_result();
void make_start();
void make_intWindow();

int doc = 5;
using namespace std;
vector<string>parse;
vector<vector<int>> docs;


map<string, int> lexicon;
map<int, map<int, vector<int>>> invertedIndex1;
map<int, map<int, vector<int>>> invertedIndex2;
map<int, map<int, vector<int>>> invertedIndex3;
map<int, map<int, vector<int>>> invertedIndex4;
map<int, map<int, int>> smallInvertedIndex;

const int fixedWidth = 500;
const int defaultHeight = 20;

// Driver function to sort the 2D vector 
// on basis of a particular column 
bool sortcol(const vector<int>& v1,
	const vector<int>& v2) {
	return v1[1] > v2[1];
};

void setting_result() {
	int fw = 100; int fh = 100;
	for (int x = 0; x < docs.size(); x++) {
		new Fl_Button(100 + fw, 100 + fh, 500, 30);
		fw += 100;
		fh += 100;
	}
	docs.resize(0);
}


void searching() {
	string word = parse[0];
	if (lexicon.find(word) != lexicon.end()) {
		int wordId = lexicon.find(word)->second;

		/*if(smallInvertedIndex.find(wordId) != smallInvertedIndex.end()) {
			map<int,int>::iterator itr = smallInvertedIndex.find(wordId)->second.begin();

			for(itr; itr != smallInvertedIndex.find(wordId)->second.end(); itr++)
				cout << itr->first << endl;
		}

		else*/ if (wordId % 4 == 0) {
			map<int, vector<int>>::iterator itr = invertedIndex4.find(wordId)->second.begin();
			{
				for (itr; itr != invertedIndex4.find(wordId)->second.end(); itr++) {
					vector<int> val;
					val.push_back(itr->first);
					val.push_back(itr->second.size());
					docs.push_back(val);
				}
			}
		}

		else if (wordId % 3 == 0) {
			map<int, vector<int>>::iterator itr = invertedIndex3.find(wordId)->second.begin();
			{
				for (itr; itr != invertedIndex3.find(wordId)->second.end(); itr++) {
					vector<int> val;
					val.push_back(itr->first);
					val.push_back(itr->second.size());
					docs.push_back(val);
				}
			}
		}

		else if (wordId % 2 == 0) {
			map<int, vector<int>>::iterator itr = invertedIndex2.find(wordId)->second.begin();
			{
				for (itr; itr != invertedIndex2.find(wordId)->second.end(); itr++) {
					vector<int> val;
					val.push_back(itr->first);
					val.push_back(itr->second.size());
					docs.push_back(val);
				}
			}

		}

		else {
			map<int, vector<int>>::iterator itr = invertedIndex1.find(wordId)->second.begin();
			{
				for (itr; itr != invertedIndex1.find(wordId)->second.end(); itr++) {
					vector<int> val;
					val.push_back(itr->first);
					val.push_back(itr->second.size());
					docs.push_back(val);

				}
			}
		}

		sort(docs.begin(), docs.end(), sortcol);
	}
		else {
		cout << "No matching results found!" << endl;
	}
	setting_result();
};


//function for searching
void parsing(string word) {
	transform(word.begin(), word.end(), word.begin(), ::tolower);
	string str;
	stringstream str1(word);
	while (getline(str1, str, ' ')) {
		parse.push_back(str);
	}
	
	searching();
};


class ScrollItem : public Fl_Group {
	// the title and author that appear in the scroll menu
	Fl_Box *docID;

public:
	ScrollItem(int X, int Y, int W, int H, const char* L = 0) : Fl_Group(X, Y, W, H, L) {
		begin();

		// Fixed docid box
		docID = new Fl_Box(X, Y, fixedWidth, defaultHeight);
		docID->box(FL_THIN_DOWN_FRAME);
		string str = to_string(docs[0][0]);
		//const char* p = str.c_str();
		//docID->label(p);
		//docs[0][0]->callback((Fl_Callback*)file_reader, (Fl_Input*));
	}
};

class MyScroll : public Fl_Scroll {
	// Custom scroll that tells children to follow scroll's width when resized
	int nchild;
public:
	MyScroll(int X, int Y, int W, int H, const char* L = 0) : Fl_Scroll(X, Y, W, H, L) {
		nchild = 0;
	}
	void resize(int X, int Y, int W, int H) {
		// Tell children to resize to our new width
		for (int t = 0; t < nchild; t++) {
			Fl_Widget *w = child(t);
			w->resize(w->x(), w->y(), W - 20, w->h());    // W-20: leave room for scrollbar
		}
		// Tell scroll children changed in size
		init_sizes();
		Fl_Scroll::resize(X, Y, W, H);
	}

	// Append new scrollitem to bottom
	//     Note: An Fl_Pack would be a good way to do this too
	//
	void AddItem() {
		int X = x() + 1,
			Y = y() - yposition() + (nchild*defaultHeight) + 1,
			W = w() - 20,                           // -20: compensate for vscroll bar
			H = defaultHeight;
		add(new ScrollItem(X, Y, W, H));
		redraw();
		nchild++;
	}
};

void file_reader(int docID) {
	string topicName = "notepad \"" + to_string(docID) + "\"";
	system(topicName.c_str());
}

void button_search(Fl_Widget* obj, void* query) {
	Fl_Input *query1 = (Fl_Input*)query;
	string s = query1->value();
	parsing(s);
};

map<string, int> loadLexicon();
map<int, map<int, vector<int>>> loadInvertedIndex1();
map<int, map<int, vector<int>>> loadInvertedIndex2();
map<int, map<int, vector<int>>> loadInvertedIndex3();
map<int, map<int, vector<int>>> loadInvertedIndex4();
//map<int, map<int, int>> loadSmallInvertedIndex();

void button_prev(Fl_Widget* obj, void* res) {
	Fl_Double_Window *result = (Fl_Double_Window*)res;
	result->hide();
	make_start();
};

void button_start(Fl_Widget* obj, void* start) {
	Fl_Window *str = (Fl_Window*)start;
	str->hide();
	make_result();
};

void button_intback(Fl_Widget* obj, void* window) {
	Fl_Window *intwin = (Fl_Window*)window;
	intwin->hide();
	make_start();
};

void button_addfiles (Fl_Widget* obj, void* window) {
	Fl_Window *win = (Fl_Window*)window;
	win->hide();
	make_intWindow();
};

// Callback to add new item to scroll
void add_cb(Fl_Widget*, void *data) {
	MyScroll *scroll = (MyScroll*)data;
	scroll->AddItem();
}

void make_start() {
	//creating window
	Fl_Window *start = new Fl_Window(600, 300, "Search Engine");

	//starting window
	start->begin();

	//setting background color
	start->color(FL_WHITE);

	//creating title
	Fl_Box *titletxt = new Fl_Box(250, 20, 100, 100, "SEARCH NEWS");
	titletxt->box(FL_NO_BOX);
	titletxt->labelfont(FL_BOLD);
	titletxt->labelsize(30);
	titletxt->labeltype(FL_SHADOW_LABEL);

	//search button
	Fl_Button *query = new Fl_Button(200, 130, 200, 30, "SEARCH");
	query->box(FL_UP_BOX);
	query->labelfont(FL_BOLD);
	query->labelsize(15);
	query->labelcolor(fl_rgb_color(162, 60, 20));

	//add button
	Fl_Button *add = new Fl_Button(200, 170, 200, 30, "ADD FILES");
	add->box(FL_UP_BOX);
	add->labelfont(FL_BOLD);
	add->labelsize(15);
	add->labelcolor(fl_rgb_color(162, 60, 20));

	//ending
	start->end();

	//adding event to button
	query->callback((Fl_Callback*)button_start, (Fl_Window*)start);
	add->callback((Fl_Callback*)button_addfiles, (Fl_Window*)start);
	
	//setting up window
	start->show();
}

void make_intWindow() {

	//creating window
	Fl_Window *intwindow = new Fl_Window(600, 300, "Search Engine");

	//starting window
	intwindow->begin();

	//setting background color
	intwindow->color(FL_WHITE);

	//creating title
	Fl_Box *inttitle = new Fl_Box(250, 20, 100, 100, "ADD FILES");
	inttitle->box(FL_NO_BOX);
	inttitle->labelfont(FL_BOLD);
	inttitle->labelsize(30);
	inttitle->labeltype(FL_SHADOW_LABEL);

	//search button
	Fl_Button *add= new Fl_Button(500, 100, 70, 30, "ADD");
	add->box(FL_UP_BOX);
	add->labelfont(FL_BOLD);
	add->labelsize(12);
	add->labelcolor(fl_rgb_color(162, 60, 20));

	//back button
	Fl_Button *intback = new Fl_Button(30, 100, 70, 30, "BACK");
	intback->box(FL_UP_BOX);
	intback->labelsize(12);
	intback->labelcolor(fl_rgb_color(162, 60, 20));
	
	//search field
	Fl_Input *inputfile = new Fl_Input(120, 100, 350, 30);
	inputfile->value("add files here");

	//ending
	intwindow->end();

	//adding event to button
	add->callback((Fl_Callback*)button_search, (Fl_Window*)intwindow);
	intback->callback((Fl_Callback*)button_intback, (Fl_Window*)intwindow);

	//setting up window
	intwindow->show();
}

void make_result() {

	//creating the output window
	Fl_Double_Window *results = new Fl_Double_Window(600, 600, "Search Results");

	//start of window
	results->begin();

	//setting background color
	results->color(FL_WHITE);

	// creating title
	Fl_Box *box = new Fl_Box(results->w() - 500,results->w() - 590, 100, 100, "SEARCH NEWS");
	box->box(FL_NO_BOX);
	box->labelfont(FL_BOLD);
	box->labelsize(30);
	box->labeltype(FL_SHADOW_LABEL);

	//search field
	Fl_Input *query = new Fl_Input(270, 40,230, 30);
	query->value("");

	//search button
	Fl_Button *search = new Fl_Button(500, 40, 70, 30, "SEARCH");
	search->box(FL_UP_BOX);
	search->labelfont(FL_BOLD);
	search->labelsize(15);
	search->labelcolor(fl_rgb_color(162, 60, 20));


	// creating label best results
	Fl_Box *best = new Fl_Box(80, 40, 100, 100, "Best Matched Documents");
	best->box(FL_NO_BOX);
	best->labelsize(17);

	//previous page
	Fl_Button *prev = new Fl_Button(results->w() - 500, results->h() - 40, 40, 25, "BACK");
	prev->box(FL_UP_BOX);
	prev->labelsize(12);
	prev->labelcolor(fl_rgb_color(162, 60, 20));

	////document autor and title listing
	//MyScroll *scroll = new MyScroll(30, 100, results->w() - 70, results->h() - 160);
	//scroll->box(FL_BORDER_BOX);
	//scroll->end();
	//Fl_Button *add_butt = new Fl_Button(results->w() - 150, results->h() - 40, 40, 25, "Add");

	//doc = 5;

	//add_butt->callback(add_cb, (void*)scroll);
	/*results->resizable(scroll);*/
	results->end();
	prev->callback((Fl_Callback*)button_prev, (Fl_Double_Window*)results);
	search->callback((Fl_Callback*)button_search, (Fl_Input*)query);
	
	//setting up window
	results->show();

}

int main(int argc, char **argv) {
	lexicon = loadLexicon();
	invertedIndex1 = loadInvertedIndex1();
	invertedIndex2 = loadInvertedIndex2();
	invertedIndex3 = loadInvertedIndex3();
	invertedIndex4 = loadInvertedIndex4();
	//smallInvertedIndex =  loadSmallInvertedIndex();

	make_start();
	return Fl::run();
}

map<string, int> loadLexicon() {
	ifstream lex;
	lex.open("lexicon.txt");
	map<string, int> lexicon;

	if (lex.fail()) {
		cout << "Error: cannot open lexicon file" << endl;
		return lexicon;
	}

	while (true) {
		string str, word;
		getline(lex, word, '\n');
		if (word == ".") break;
		getline(lex, str, '\n');
		lexicon.insert({ word,stoi(str) });
	}

	return lexicon;
};

map<int, map<int, vector<int>>> loadInvertedIndex1() {
	ifstream index;
	index.open("inverted_index1.txt");
	map<int, map<int, vector<int>>> invertedIndex;

	while (!index.eof()) {
		map<int, vector<int>> hits;
		string str;
		getline(index, str, '\n');
		if (str == "") break;
		int wordID = stoi(str);
		while (true) {
			getline(index, str, '\n');
			if (str == "_") break;
			int dID = stoi(str);
			vector<int> temp;

			while (true) {
				getline(index, str, '\n');
				if (str == "." || str == "_") break;
				temp.push_back(stoi(str));
			}

			hits.insert({ dID,temp });
		}

		invertedIndex.insert({ wordID, hits });
	}

	return invertedIndex;
};

map<int, map<int, vector<int>>> loadInvertedIndex2() {
	ifstream index;
	index.open("inverted_index2.txt");
	map<int, map<int, vector<int>>> invertedIndex;

	while (!index.eof()) {
		map<int, vector<int>> hits;
		string str;
		getline(index, str, '\n');
		if (str == "") break;
		int wordID = stoi(str);
		while (true) {
			getline(index, str, '\n');
			if (str == "_") break;
			int docID = stoi(str);
			vector<int> temp;

			while (true) {
				getline(index, str, '\n');
				if (str == "." || str == "_") break;
				temp.push_back(stoi(str));
			}

			hits.insert({ docID,temp });
		}

		invertedIndex.insert({ wordID, hits });
	}

	return invertedIndex;
};

map<int, map<int, vector<int>>> loadInvertedIndex3() {
	ifstream index;
	index.open("inverted_index3.txt");
	map<int, map<int, vector<int>>> invertedIndex;

	while (!index.eof()) {
		map<int, vector<int>> hits;
		string str;
		getline(index, str, '\n');
		if (str == "") break;
		int wordID = stoi(str);
		while (true) {
			getline(index, str, '\n');
			if (str == "_") break;
			int docID = stoi(str);
			vector<int> temp;

			while (true) {
				getline(index, str, '\n');
				if (str == "." || str == "_") break;
				temp.push_back(stoi(str));
			}

			hits.insert({ docID,temp });
		}

		invertedIndex.insert({ wordID, hits });
	}

	return invertedIndex;
};

map<int, map<int, vector<int>>> loadInvertedIndex4() {
	ifstream index;
	index.open("inverted_index4.txt");
	map<int, map<int, vector<int>>> invertedIndex;

	while (!index.eof()) {
		map<int, vector<int>> hits;
		string str;
		getline(index, str, '\n');
		if (str == "") break;
		int wordID = stoi(str);
		while (true) {
			getline(index, str, '\n');
			if (str == "_") break;
			int docID = stoi(str);
			vector<int> temp;

			while (true) {
				getline(index, str, '\n');
				if (str == "." || str == "_") break;
				temp.push_back(stoi(str));
			}

			hits.insert({ docID,temp });
		}

		invertedIndex.insert({ wordID, hits });
	}

	return invertedIndex;
};

map<int, map<int, int>> loadSmallInvertedIndex() {
	ifstream index;
	index.open("small_inverted_index.txt");
	map<int, map<int, int>> smallInvertedIndex;

	while (!index.eof()) {
		map<int, int> fancyHits;
		string str;
		getline(index, str, '\n');
		if (str == "")
			break;

		int wordID = stoi(str);
		while (true) {
			getline(index, str, '\n');

			if (str == "_")
				break;

			int docID = stoi(str);
			getline(index, str, '\n');
			int count = stoi(str);

			fancyHits.insert({ docID,count });
		}
		smallInvertedIndex.insert({ wordID, fancyHits });
	}

	return smallInvertedIndex;
};
